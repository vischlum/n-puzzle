"""
The content of the file is parsed, with a parser generated by Lark
according to the given abstract grammar.
Then the formatting of the puzzle is checked.
"""

import itertools
import sys
import lark

from dataclass import Puzzle
from solvability import check_solvability


class TreeToPuzzle(lark.visitors.Transformer):  # type: ignore
    """
    A Lark Transformer class allows to specify how to process
    the data in the parsing tree, with a function for each token.
    """

    @staticmethod
    def size(token: list[lark.lexer.Token]) -> int:
        """
        Returns the int value of the size token
        """
        return int(token[0])

    @staticmethod
    def grid(rows: list[lark.tree.Tree]) -> list[list[int]]:
        """
        Returns the grid as a list of lists of int
        """
        clean_grid = []
        row: lark.tree.Tree
        for row in rows:
            clean_row = []
            tile: lark.lexer.Token
            for tile in row.children[:-1]:  # type: ignore
                clean_row.append(int(tile.value))
            clean_grid.append(clean_row)
        return clean_grid

    puzzle = tuple


def parsing(file_content: str) -> tuple[int, list[list[int]]]:
    """
    Combines an abstract grammar with the Transformer to easily get a tuple
    containing the size and the grid of the puzzle.
    """
    grammar = lark.Lark(
        r"""
    puzzle: size grid

    size : STRICTLY_POSITIVE_NUMBER NEWLINE
    grid: row+
    row.1 : NUMBER (NUMBER)* NEWLINE
    STRICTLY_POSITIVE_NUMBER : ("1".."9")+
    NUMBER : INT

    %import common.SH_COMMENT
    %import common.NEWLINE
    %import common.INT
    %import common.WS
    %ignore SH_COMMENT
    %ignore NEWLINE
    %ignore WS
    """,
        start="puzzle",
    )

    tree = grammar.parse(file_content)
    puzzle: tuple[int, list[list[int]]] = TreeToPuzzle().transform(tree)
    return puzzle


def check_format(puzzle: tuple[int, list[list[int]]]) -> tuple[int, tuple[int, ...]]:
    """
    Checks that the grid is properly formatted:
    - both the height and width are equal to the size
    - the grid contains all the required numbers
    """
    size: int
    grid: list[list[int]]
    size, grid = puzzle

    if size != len(grid):
        sys.exit(
            "\033[31;1mFormat Error: the grid doesn't fit the required height.\033[m"
        )

    for row in grid:
        if size != len(row):
            sys.exit("\033[31;1mFormat Error: wrong length for one of the row.\033[m")

    correct_grid = list(range(size ** 2))
    merged_grid = tuple(itertools.chain.from_iterable(grid))
    sorted_grid = sorted(merged_grid)
    if correct_grid != sorted_grid:
        sys.exit(
            "\033[31;1mFormat Error: one of the number is missing in the grid.\033[m"
        )

    return size, merged_grid


def parsing_main(file_content: str, shape: str) -> Puzzle:
    """
    Calls all the necessary functions to ensure the puzzle is valid
    (ie properly formatted and solvable)
    """
    initial_puzzle: tuple[int, list[list[int]]] = parsing(file_content)
    clean_puzzle: tuple[int, tuple[int, ...]] = check_format(initial_puzzle)

    puzzle = Puzzle(*clean_puzzle, shape)

    if check_solvability(puzzle) is False:
        sys.exit(
            "\033[31;1mThe puzzle cannot be solved: its inversion sum is an odd number.\033[m"
        )

    return puzzle
